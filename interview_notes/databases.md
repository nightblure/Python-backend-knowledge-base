## Материализованное представление

Материализованное представление – это **копия результатов запроса**. 
Данные из запроса, связанного с материализованным представлением, 
будут сброшены на диск (**закэшированы**), что увеличит скорость доступа к данным такого представления.

_Материализованное представление нужно обновлять вручную для поддержания актуальности данных_!

---

## Индексы

**Индекс** – объект, создаваемый с целью повышения производительности поиска данных. 
**Индекс хранит ссылки на страницы**, в которых лежат записи.

Индексы могут уменьшить производительность, если применяются в таблицах, 
где часто происходят операции *INSERT*, *DELETE* и *UPDATE*, 
т.к. меняя содержимое таблицы нужно перестраивать и ее индексы.

**Индексы занимают дополнительный объем памяти**, т.к. хранятся на диске.

| **Индекс**                                                                                                          | **Кейсы для применения**                                                                                                                                                                                                                                                                                                                         |
|---------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ***btree*** – **сбалансированное дерево**. Является индексом по умолчанию*.* Наиболее часто применяемый вид индекса | Любые данные, с которыми можно проводить **операции сравнения**                                                                                                                                                                                                                                                                                  |
| ***hash*-индексы** – хеширование значений индексированного поля таблицы                                             | **Работает только с простыми условиями равенства**  Используется *PostgreSQL* для соединения таблиц, если у таблиц нет индексов. СУБД временно создает хеш-индексы для таблиц, соединяет их и затем удаляет хеш-индексы.                                                                                                                         |
| ***GiST (R-Tree)***                                                                                                 | Позволяет индексировать значения, перекрывающиеся между собой. Это могут быть значения многомерных структур хранения данных типа координат в многомерном пространстве  Индексация географических типов данных                                                                                                                                    |
| ***GIN* (инвертированный индекс)**                                                                                  | Полнотекстовый поиск, поиск по *JSON*-полям                                                                                                                                                                                                                                                                                                      |
| **Частичный индекс**                                                                                                | Применяется, когда нет цели индексировать данные целиком.  **Пример**: *CREATE INDEX idx_table_field ON table (field) WHERE field IS NOT NULL*  **Недостаток**: чтобы индекс применялся, необходимо в запросы «таскать» выражение, указанное при создании индекса (в примере это выражение *IS NOT NULL*).                                       |
| **Функциональный индекс**                                                                                           | Применяется, когда есть необходимость проиндексировать не сами значения, а результаты функций от этих значений.  **Пример**: *CREATE INDEX idx_table_field ON table (LOWER(field))*  **Недостаток**: чтобы индекс применялся, необходимо в запросы «таскать» выражение, указанное при создании индекса (в примере это выражение *LOWER(field)*). |
| **Кластерный индекс**                                                                                               | Кластеризация сортирует данные по указанному индексу. То есть она применяется к таблице и ранее созданному индексу  Кластеризация является одноразовой операцией: последующие изменения в таблице нарушают порядок кластеризации                                                                                                                 |

---

## Оптимизация запросов

Сначала нужно понять к каким данным СУБД обращается чаще всего и какие запросы выполняются дольше всего.

**Долгое выполнение запросов может быть связано с внешними факторами**: 
например, в момент выполнения запроса выполнялось резервное копирование или в то же 
время сервер обрабатывал другие тяжелые запросы. **То есть дело может быть не в самом запросе.**

**1 шаг (статистика)**: собрать статистику выполнения запросов, например, с помощью расширения ***pg_stat_statements***. 
Сначала нужно активировать расширение в файле конфигурации ***postgresql.conf***, добавив в него строки:

```bash
shared_preload_libraries = ‘pg_stat_statements’
-- соберет статистику по 1000 наиболее используемых запросов
pg_stat_statements.max = 1000
pg_stat_statements.track = all
```

**Обращение к статистике**:

```sql
SELECT 
    query, calls, total_time, rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements
ORDER BY total_time DESC LIMIT 10;
```

**1 шаг (альтернативный способ: лог)**: подключить в ***postgresql.conf*** логирование запросов, 
время выполнения которых **превышает заданную величину** в миллисекундах:
```bash
log_duration = on
log_lock_waits = on

-- время выполнения (в мс.), превысив которое запрос попадает в лог
log_min_duration_statement = 100
log_filename = ‘postgresql-%Y-%m-%d_%H%M%S’
log_directory = ‘/var/log/postgresql’
log_destination = ‘csvlog’
logging_collector = on
```

Просматривать отчеты, сделанные на основе логов, можно с помощью утилиты ***pgbadger***, 
которую необходимо установить отдельно.

**2 шаг:** посмотреть план запроса с помощью операторов ***EXPLAIN ANALYZE* 
(**их можно использовать как вместе, так и раздельно, см. далее**)**.

***EXPLAIN*** построит и покажет только план выполнения, но не выполнит запрос.

***ANALYZE*** соберет статистику используемых таблиц, **выполнит** **запрос** **(!)** и покажет время его выполнения.

**Пример**
```bash
EXPLAIN SELECT * FROM tenk1;

QUERY PLAN

-------------------------------------------------------------

Seq Scan on tenk1 (cost=0.00..458.00 rows=10000 width=244)
```

Числа, перечисленные в скобках (слева направо), имеют следующий смысл:

* приблизительная **стоимость запуска** (время, спустя которое начнётся этап вывода данных);
* приблизительная **общая стоимость (*cost*). 1 *cost* = 1 операция чтения страницы с диска**;
* ожидаемое **число строк**, которое должен вывести этот **узел плана**;
* ожидаемый **средний размер строк**, выводимых этим узлом плана (в байтах).

Если требуется проанализировать с помощью *EXPLAIN* *ANALYZE* запросы типа *DELETE*, *UPDATE* и *INSERT*, то необходимо обернуть их в транзакцию, т.к. *ANALYZE* выполняет запрос:
```sql
BEGIN;
EXPLAIN ANALYZE <query>;
ROLLBACK;
```

Важно помнить о том, что при выполнении запроса **планировщик выбирает план выполнения**, 
**опираясь на** **статистику**. 
Следовательно, при анализе запроса путем использования оператора *EXPLAIN* **нужно убедиться, что статистика не устарела**.

**Собрать статистику** можно, вызвав *ANALYZE* с именем таблицы, или просто *ANALYZE*, чтобы проанализировать все таблицы БД.

**Шаг 3: анализ**: при анализе нужно обращать внимание на следующие моменты:

* операции с большой ***cost***;
* узлы плана с последовательным чтением (***seq scan***), часто указывающие на отсутствие необходимых индексов;
* ***sort*** – операции сортировки являются дорогими.

**Дальнейшие возможные шаги**:

* на сервере **можно запускать** **автоочистку и автоанализ** (***autovacuum***) 
для удаления неиспользуемых записей (мертвых кортежей);

* **денормализация** – привнесение избыточности;

* **использование** **табличных пространств** – управление размещением объектов 
по физическим устройствам ввода/вывода. Например, активно используемые данные хранить на *SSD* дисках,
а архивные – на более медленных *HDD*.

* **партиционирование** – разделение большой таблицы на множество более мелких;

* **замена подзапросов в запросах на соединения**;

* **деградация функциональности** – намеренное понижение количества 
передаваемых клиенту данных (например, вместо топ-100 друзей отдаем топ-10).

---

## Масштабирование баз данных

**Вертикальное масштабирование** предполагает наращивание мощности текущего сервера (добавление памяти, замена CPU и т.д.).

**Горизонтальное масштабирование** предполагает разделение данных по разным серверам или разным инстансам сервисов.

Реализовать масштабирование можно несколькими способами:

* **партиционирование** – разбиение данных на несколько частей по определенному признаку (например, разбиваем таблицу на две части по четности поля *ID*);
* **шардирование** – хранение данных на разных серверах или инстансах БД;
* **репликация**.

---

## Уровни изолированности транзакций

Стандарт SQL определяет **4 уровня изолированности транзакций**.

Пусть **T1** – **первая транзакция**, а **T2** – **вторая транзакция**.

***L1. READ UNCOMMITTED*** («грязное» чтение) – **T1** **видит изменения**, выполненные **незавершенной** **T2**. 
Этот уровень не реализован в *PostgreSQL*, т.к. не представляет практической ценности.

***L2. READ COMMITTED*** (чтение зафиксированных данных) – *T1* увидит изменения, выполненные *T2*, после коммита (фиксации) *T2*.

Попытка изменения одних и тех же данных в *T2* до коммита изменений *T1* будет заблокирована. ***Является уровнем по умолчанию в *PostgreSQL***.

***L3. REPEATABLE READ*** (повторяемое чтение) – *T1* увидит изменения, выполненные *T2*, только после коммита *T2* и *T1*.

Попытка изменения одних и тех же данных в *T2* до коммита изменения в *T1* будет заблокирована.

***L4. SERIALIZABLE*** – уровень, на котором моделируется последовательное выполнение всех зафиксированных транзакций. Если транзакции обращаются к одной и той же таблице, зафиксируются изменения только той транзакции, которая зафиксируется быстрее всех.

Шаблон для наглядного представления и работы с уровнями изоляции (нужна заранее созданная БД с таблицей *test* и еще одним пользователем помимо *postgres*):

*T1* (сессия пользователя *postgres*):
```sql
-- READ COMMITTED
-- REPEATABLE READ
-- SERIALIZABLE

DELETE FROM test;
INSERT INTO test VALUES (1), (2);

SELECT * FROM test

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
UPDATE test SET id = id + 10 WHERE id = 1;
COMMIT;
```

*T2* (сессия пользователя *test*):

```sql
SELECT * FROM test
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- можно поменять id на 1, чтобы увидеть блокировки
UPDATE test SET id = id + 10 WHERE id = 2;
COMMIT;
```

---

## CAP-теорема

Это утверждение о том, что в любой реализации распределенных вычислений возможно обеспечить **не более двух** 
из трех следующих свойств (возможные комбинации свойств: ***CA, CP, AP***):

***Consistency*** – состояние согласованности данных во всех вычислительных узлах (одни и те же данные у мастеров и реплик и т.д.);

***Availability*** – доступность системы;

***Partition tolerance*** – система способна работать в случае отказа некоторых вычислительных узлов 
(**это свойство по умолчанию соблюдается микросервисной архитектурой.** 
Иными словами, для микросервисной архитектуры стоит выбор отказа от **_Consistency_** или **_Availabiblity_**).

---

## Репликация

**Репликация** – механизм синхронизации нескольких наборов данных.

Существуют два вида репликации: **физическая** и **логическая**. Оба вида будут описаны ниже.

Также существуют **гарантии** **репликации**: **синхронная** и **асинхронная.**

**Синхронная** репликация подразумевает, что мастер-сервер фиксирует транзакцию только после момента подтверждения получения данных репликой.

**Асинхронная** же подразумевает обратное: **мастер не ждет подтверждения получения данных** от реплики.

**По виду взаимодействия** репликация может быть **мастер-слейв** и **мастер-мастер.**

**Мастер-слейв репликация** предполагает главного (мастер) сервера и подчиненного (слейв) сервера. **Слейв повторяет состояние мастера** и не может менять данные самостоятельно.

**Репликация** **мастер-мастер предполагает равенство серверов**. Оба сервера могут обрабатывать запросы на чтение и изменение данных.

**Применение** репликации:

* **балансировка нагрузки**;
* **обеспечение отказоустойчивости** (переход на реплику в случае сбоя основного сервера);
* **тестирование новых версий *PostgreSQL***.

**Физическая** (**потоковая**) репликация – вид репликации, в основе которого лежит **передача записей журнала транзакций** от мастера к реплике. **Реплика применяет изменения**, принятые от мастера, **чисто механически**, без «понимания смысла», работая **в режиме постоянного восстановления**. Поэтому данный вид репликации можно применить только в условиях полной программно-аппаратной совместимости мастер и слейв серверов (одна архитектура *CPU* и версия *PostgreSQL*).

**Недостатки** физической репликации:

* мастер может отдать слейву испорченные данные, например, в случае сбоев *RAM*;
* на реплике не может быть локальных изменений схемы данных;
* требовательность к платформе и версии *PostgreSQL*;
* невозможность репликации мастер-мастер.

В основе **логической** репликации лежит принцип ***publisher*-*subscriber***, при этом у серверов нет выделенных ролей: **один и тот же сервер может публиковать изменения и быть подписчиком**.

Сервер-публикатор читает журнальные записи и предварительно декодирует в «логический», платформо-независимый вид. Поэтому логическая репликация не требует жесткой совместимости серверов, реплика должна лишь понимать протокол репликации.

**Логическая репликация не реплицирует** команды *DDL* (все изменения схемы данных нужно переносить вручную), значения последовательностей.

**Плюсы** логической репликации:

* репликация остановится, если мастер имеет аппаратные неисправности;
* нетребовательность к программной совместимости;
* возможность использования различающихся схем данных на мастере и слейве;
* возможность настройки мастер-мастер репликации.

---

## Денормализация

Под денормализацией понимают **намеренное нарушение требований нормализации**.

Денормализация обычно проводится путем добавления данных, которые согласно требования нормальных форм должны выноситься в отдельную таблицу (избыточность данных).

**Применение**: в случае долгого выполнения соединений в запросе можно **внести дополнительное поле** из присоединяемой таблицы в нужную таблицу.

Также можно построить так называемые **вертикальные таблицы**, в которых строки будут использоваться для хранения наименований полей и их значений:

Денормализация приводит к избыточности и дублированию данных, поэтому выигрыш от нее должен оправдывать затраты.

---

## ACID (свойства транзакционной СУБД)

***Atomicity*** – **атомарность** операций. Транзакция должна быть выполнена полностью, либо вовсе не выполнена.

***Consisitency*** – **согласованность**. Обеспечение целостности данных, 
выполнения определенных правил и ограничений (триггеры, непустые поля, ограничения на уникальность и внешние ключи и т.д.).

***Isolation*** – **изолированность**. Выполнение параллельных транзакций 
не должно влиять на итоговый результат другой транзакции.
**Это очень дорогое требование, поэтому оно частично и по-разному выполняется в соответствии с уровнями изолированности транзакций**.

***Durability*** – **долговечность**. Изменения успешно завершенной транзакции не должны пропасть в случае сбоев.

---
