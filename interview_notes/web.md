## HTTP

**HTTP** (*HyperText Transfer Protocol*) – протокол, описывающий правила взаимодействия клиента и сервера.

**Взаимодействие** **клиента и сервера** осуществляется путем обмена *HTTP*-сообщениями. 
*HTTP*-запрос **клиента** состоит из следующих частей:
```
<Метод> <Ресурс> <Протокол/версия>
```

**Пример**: 
```
PUT /create-page HTTP/1.1
<заголовки запроса>
<тело запроса> (требуется не для всех методов)
```

**Заголовки** – пары вида ключ-значение, необходимые 
для передачи служебной информации (тип контента, браузер, устройство и т.д.).

**Метод** – последовательность символов, определяющую операцию для осуществления над ресурсом. 
Спецификация *HTTP* не ограничивает набор методов, но принято использовать конкретные методы:
* ***GET*** – получение ресурса (***HEAD*** –то же самое только без содержимого);
* ***POST*** – создание ресурса;
* ***PUT*** – изменение ресурса (***PATCH*** – частичное изменение);
* ***DELETE*** – удаление ресурса;
* ***OPTIONS*** – информация о соединении.

***URL*** – идентификатор/путь до ресурса.

*HTTP* не обязывает сервер реализовывать методы строго определенным образом и понимать все методы.
Только метод *GET* является обязательным для реализации.

***HTTP***-**ответ** **сервера** выглядит следующим образом:
```
HTTP/<версия> <Код состояния> <Пояснение>
<заголовки>
<тело ответа>
```

**Код состояния** указывает на результат обработки запроса клиента. Коды принято классифицировать следующим образом:
* **1xx**: *Information* (**информационные**);
* **2xx**: *Success* (**успешные**);
* **3xx**: *Redirect* (**перенаправления**);
* **4xx**: *Client* *Error* (**клиентские ошибки**);
* **5xx**: *Server* *Error* (**серверные** **ошибки**).


---

## **Как браузер обрабатывает запрос клиента**

1. **браузер получает** из адресной строки **протокол** (*http*/*https*), 
**доменное имя хоста** и **ресурс** (`/api/v2/some_resource/...`)`;

2. **браузер получает IP адрес хоста** путем **одним из способов**:
   * из кэша ОС, если ранее на этот хост отправлялись запросы;
   * резолв доменного имени хоста в *IP* с помощью ***DNS***;

3. **браузер устанавливает соединение** с хостом **одним из способов**:
   * **незащищенное** по протоколу *http* по 80 порту;
   * **защищенное** по *https* по 443 порту с проверкой подлинности, хендшейками и т.д.

4. браузер получает ответ от хоста и рендерит *HTML*.


---

## Идемпотентность HTTP методов

Метод *HTTP* является **идемпотентным**, 
если один и тот же неоднократно выполненный запрос оказывает один и тот же эффект, 
не изменяющий состояние сервера. 
Другими словами, идемпотентный метод не должен иметь никаких сайд-эффектов, кроме сбора статистики или подобных операций.

Методы [***GET***](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET)***,
***[***HEAD***](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/HEAD)***,
***[***PUT***](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/PUT),
[***DELETE***](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/DELETE) и 
***OPTIONS*** **идемпотентны** в отличие от методов [***POST***](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST)и ***PATCH***.

Для идемпотентности нужно рассматривать только изменение фактического внутреннего состояния сервера, 
а возвращаемые запросами коды статуса могут отличаться: 
первый вызов [*DELETE*](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/DELETE) вернёт код [**200**](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/200), 
а любой следующий вызов вернет [404](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/404) (поэтому *DELETE* идемпотентен).

---

## ***REST* / *RESTful***

**REST** – это архитектурный стиль построения клиент-серверных приложений.

**_RESTful_** приложение должно соблюдать следующие **5/6** принципов ***REST***:

1. **клиент-серверная архитектура**;

2. ***stateless*** (**отсутствие хранения состояния**) – сервер не должен хранить информацию о предыдущих запросах клиента;

3. **кэшируемость** – должна быть возможность по требованию клиента сохранить данные в кэш и отдавать эти данные из кэша;

4. **единообразие** **интерфейса** – использование одного протокола для общения клиента и сервера;

5. **многоуровневая система –** система может быть сложной, но эта сложность скрыта от клиента;

6. **код по требованию** (необязательное требование *RESTful*) – 
при необходимости сервер может расширить функционал клиента (валидация номера телефона на форме и т.д.).

---

## ***JSON Web Tokens (JWT)***

***JWT*** – это открытый стандарт для создания токенов, основанных на формате ***JSON***. 
Этот вид токенов **используется для аутентификации в веб-приложениях**.

***JSON Web Token*** делится на **3 составляющие** и может выглядеть следующим образом:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV\_adQssw5c
```

**Компоненты JWT**:

* **заголовок** (***header***) – содержит **закодированную** информацию об алгоритме шифрования **подписи** 
(`{'alg':''HS256', 'typ':'JWT'}`);

* **полезная информация** (***payload***) – любая **закодированная** информация, которую сервер может передать клиенту 
(`{'email':'example@mail.com'}`);

* **подпись (*signature*) –** строка вида `MAC-SHA256(f'{header}.{payload}, SECRET_KEY)`, 
**зашифрованная** **секретным** **ключом** на стороне сервера аутентификации.


### Принцип работы

**Принцип работы *JWT***: любой пользователь сможет **раскодировать заголовок и полезную информацию**,
т.к. они **закодированы**, а **не зашифрованы**. 
Изменение содержимого любой части токена потребует создания новой подписи, 
но злоумышленник не сможет сгенерировать корректную подпись, т.к. не знает секретного ключа.

**Токены обычно генерируются парами**:
* ***access_token*** – **токен для аутентификации пользователя**, 
имеющий ограниченное время действия, заданное сервером аутентификации;

* ***refresh_token*** – токен, необходимый для генерации нового *access\_token* после завершения срока действия последнего.

### Механика работы access и refresh токенов

**Access token (АТ)** живет как правило очень **короткое время** и его можно хранить в **local storage** или **cookie**. 
При этом **refresh token (RT)** должен жить намного дольше **АТ** и храниться в куке с флагами **httpOnly** и **Secure**.

Когда **АТ** истек, а **RT** еще жив, клиент должен получить новый **AT** с помощью **RT**. 
А когда **RT** истек, нужно повторить процесс логина (обычно с логином и паролем). 
Обычно принято возвращать из эндпоинта логина пару **AT**+**RT**.

---

