# Apache Kafka

## Гарантии доставки

У **паблишера** можно указать параметр `acks` с одним из значений:
- **none** - не ждать подтверждения (семантика **most once**);
- **one** - ждать подтверждение от лидера (семантика **least once**);
- **all** - ждать подтверждения от лидера и `in-sync` реплик (семантика **least once** с повышенной надежностью).

У **консьюмера** есть следующие возможности:
1. `offset commit` **до обработки сообщения** (семантика **most once**);

2. `offset commit` **после обработки сообщения** - 
сообщение не теряется, но может быть повторно обработано, если в консьюмер упадет (семантика **least once**):

Семантика **exactly once** достигается за счет:
- **идемпотентных продюсеров** (конфиг параметр `enable.idempotence=true`);
- **транзакции** kafka.
---

## Разные вопросы
* **гарантия порядка сообщений**: **гарантируется** только **в рамках одной партиции**;


* **DLQ/DLT** - можно сделать мидлварь и при ошибках скидывать сообщения в заранее выделеный топик;


* **как параллельно обрабатывать данные из одного топика** - для **параллельного** чтения данных из топика
нужно **объединить консьюмеров в консьюмер-группу** с помощью указания одинакового **идентификатора группы** 
(_каждая партиция будет назначена своему выделенному консьюмеру_);


* **запись в определенную партицию** можно сделать с помощью **ключа партиции**, **указываемого у продюсера**;

---

## Отличия RabbitMQ от Apache Kafka

1. **RMQ** работает по **push**-модели (**консьюмеры сами получают сообщения**), 
а **Kafka** реализует **pull**-модель (**консьюмеры сами ходят в кафку за сообщениями**); 

2. **RMQ удаляет сообщения** из очереди после их обработки и подтверждения (**acknowledgment**),
**Kafka хранит сообщения на диске** в соответствии с _retention policy_;

3. **RMQ** умеет в гибкую маршрутизацию сообщений.
---
