# Apache Kafka

## Гарантии доставки

1. **Most once** - **обеспечивается подтверждением** обработки сообщения **ДО** фактической его **обработки**:
```python
def consume(msg):
    msg.ack()
    ...  # фактическая обработка сообщения
```
2. **Least once** - **обеспечичвается подтверждением после обработки сообщения**:
```python
def consume(msg):
    ...  # фактическая обработка сообщения
    msg.ack()
```

Также на гарантии доставки может влиять наличие/отсутствие **ожидания доставки** до
заданного количества **реплик** (_insync replicas_).

Поведение можно регулировать параметрами `acks` и `min_insync_replicas`:
```python
"""
в этой конфигурации msg.ack() сработает, 
только когда сообщение будет доставлено до 2 реплик и мастера
"""
producer = KafkaProducer(
    bootstrap_servers=..., 
    acks='all', 
    min_insync_replicas=2
)
```

---

## Разные вопросы по кафке
* **гарантия порядка сообщений**: гарантируется только в рамках одной партиции;

* **DLQ/DLT** - можно сделать мидлварь и при ошибках скидывать сообщения в заранее выделеный топик;

* **consumer group** - консьюмер-группа нужна для параллельного чтения данных из топика. 
В этом случае каждая партиция будет назначена своему выделенному консьюмеру;

* **запись в определенную партицию** можно сделать с помощью ключа партиции, указываемого у продюсера;

---

## Отличия RabbitMQ от Apache Kafka

1. **RMQ** работает по **push**-модели (**консьюмеры сами получают сообщения**), 
а **Kafka** реализует **pull**-модель (**консьюмеры сами ходят в кафку за сообщениями**); 

2. **RMQ удаляет сообщения** из очереди после их обработки и подтверждения (**acknowledgment**),
**Kafka хранит сообщения на диске** в соответствии с _retention policy_;

3. RMQ умеет в гибкую маршрутизацию сообщений, но Kafka из коробки лучше заточена под масштабирование
за счет разбития топиков на партиции.
---
